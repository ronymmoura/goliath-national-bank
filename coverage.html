
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ronymmoura/goliath-national-bank/api/account.go (100.0%)</option>
				
				<option value="file1">github.com/ronymmoura/goliath-national-bank/api/server.go (88.2%)</option>
				
				<option value="file2">github.com/ronymmoura/goliath-national-bank/api/transfer.go (100.0%)</option>
				
				<option value="file3">github.com/ronymmoura/goliath-national-bank/api/user.go (100.0%)</option>
				
				<option value="file4">github.com/ronymmoura/goliath-national-bank/api/validator.go (66.7%)</option>
				
				<option value="file5">github.com/ronymmoura/goliath-national-bank/db/mock/store.go (30.9%)</option>
				
				<option value="file6">github.com/ronymmoura/goliath-national-bank/db/sqlc/account.sql.go (91.4%)</option>
				
				<option value="file7">github.com/ronymmoura/goliath-national-bank/db/sqlc/db.go (50.0%)</option>
				
				<option value="file8">github.com/ronymmoura/goliath-national-bank/db/sqlc/entry.sql.go (85.7%)</option>
				
				<option value="file9">github.com/ronymmoura/goliath-national-bank/db/sqlc/store.go (74.3%)</option>
				
				<option value="file10">github.com/ronymmoura/goliath-national-bank/db/sqlc/transfer.sql.go (85.7%)</option>
				
				<option value="file11">github.com/ronymmoura/goliath-national-bank/db/sqlc/user.sql.go (100.0%)</option>
				
				<option value="file12">github.com/ronymmoura/goliath-national-bank/main.go (0.0%)</option>
				
				<option value="file13">github.com/ronymmoura/goliath-national-bank/token/jwt_maker.go (100.0%)</option>
				
				<option value="file14">github.com/ronymmoura/goliath-national-bank/token/paseto_maker.go (100.0%)</option>
				
				<option value="file15">github.com/ronymmoura/goliath-national-bank/token/payload.go (100.0%)</option>
				
				<option value="file16">github.com/ronymmoura/goliath-national-bank/util/currency.go (100.0%)</option>
				
				<option value="file17">github.com/ronymmoura/goliath-national-bank/util/password.go (100.0%)</option>
				
				<option value="file18">github.com/ronymmoura/goliath-national-bank/util/random.go (100.0%)</option>
				
				<option value="file19">github.com/ronymmoura/goliath-national-bank/util/util.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        db "github.com/ronymmoura/goliath-national-bank/db/sqlc"
)

type CreateAccountRequest struct {
        UserID   uuid.UUID `json:"user_id" binding:"required"`
        Currency string    `json:"currency" binding:"required,oneof=USD EUR CAD BRL"`
}

func (server *Server) createAccount(ctx *gin.Context) <span class="cov8" title="1">{
        var req CreateAccountRequest

        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">arg := db.CreateAccountParams{
                UserID:   req.UserID,
                Currency: req.Currency,
                Balance:  0,
        }

        account, err := server.store.CreateAccount(ctx, arg)
        if err != nil </span><span class="cov8" title="1">{
                if pgErr, ok := err.(*pgconn.PgError); ok </span><span class="cov8" title="1">{
                        switch pgErr.Code </span>{
                        case "23505", "23503":<span class="cov8" title="1">
                                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                                return</span>
                        }
                }

                <span class="cov8" title="1">ctx.JSON(http.StatusInternalServerError, errorResponse(err))
                return</span>
        }

        <span class="cov8" title="1">ctx.JSON(http.StatusCreated, account)</span>
}

type ListAccountRequest struct {
        Page     int32 `form:"page" binding:"required,min=1"`
        PageSize int32 `form:"page_size" binding:"required,min=5,max=10"`
}

func (server *Server) listAccounts(ctx *gin.Context) <span class="cov8" title="1">{
        var req ListAccountRequest

        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">arg := db.ListAccountsParams{
                Limit:  req.PageSize,
                Offset: (req.Page - 1) * req.PageSize,
        }

        accounts, err := server.store.ListAccounts(ctx, arg)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, accounts)</span>
}

type GetAccountRequest struct {
        AccountID int64 `uri:"account_id" binding:"required,min=1"`
}

func (server *Server) getAccount(ctx *gin.Context) <span class="cov8" title="1">{
        var req GetAccountRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">account, err := server.store.GetAccount(ctx, req.AccountID)
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        ctx.JSON(http.StatusNotFound, errorResponse(err))
                        return
                }</span>

                <span class="cov8" title="1">ctx.JSON(http.StatusInternalServerError, errorResponse(err))
                return</span>
        }

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, account)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/gin-gonic/gin/binding"
        "github.com/go-playground/validator/v10"
        db "github.com/ronymmoura/goliath-national-bank/db/sqlc"
        "github.com/ronymmoura/goliath-national-bank/token"
        "github.com/ronymmoura/goliath-national-bank/util"
)

type Server struct {
        config     util.Config
        store      db.Store
        tokenMaker token.Maker
        router     *gin.Engine
}

func NewServer(config util.Config, store db.Store) (server *Server, err error) <span class="cov8" title="1">{
        tokenMaker, err := token.NewPasetoMaker(config.TokenSymmetricKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create token maker: %w", err)
        }</span>

        <span class="cov8" title="1">server = &amp;Server{
                config:     config,
                store:      store,
                tokenMaker: tokenMaker,
        }
        router := gin.Default()

        if v, ok := binding.Validator.Engine().(*validator.Validate); ok </span><span class="cov8" title="1">{
                v.RegisterValidation("currency", validCurrency)
        }</span>

        <span class="cov8" title="1">router.GET("users/:user_id", server.getUser)
        router.POST("users", server.createUser)

        router.GET("accounts", server.listAccounts)
        router.GET("accounts/:account_id", server.getAccount)
        router.POST("accounts", server.createAccount)

        router.POST("transfers", server.createTransfer)

        server.router = router
        return</span>
}

func (server *Server) Start(address string) error <span class="cov0" title="0">{
        return server.router.Run(address)
}</span>

func errorResponse(err error) gin.H <span class="cov8" title="1">{
        return gin.H{"error": err.Error()}
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/jackc/pgx/v5"
        db "github.com/ronymmoura/goliath-national-bank/db/sqlc"
)

type TransferRequest struct {
        FromAccountID int64  `json:"from_account_id" binding:"required,min=1"`
        ToAccountID   int64  `json:"to_account_id" binding:"required,min=1"`
        Amount        int64  `json:"amount" binding:"required,gt=0"`
        Currency      string `json:"currency" binding:"required,currency"`
}

func (server *Server) createTransfer(ctx *gin.Context) <span class="cov8" title="1">{
        var req TransferRequest

        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">if !server.validAccount(ctx, req.FromAccountID, req.Currency) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !server.validAccount(ctx, req.ToAccountID, req.Currency) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">arg := db.TransferTxParams{
                FromAccountID: req.FromAccountID,
                ToAccountID:   req.ToAccountID,
                Amount:        req.Amount,
        }

        result, err := server.store.TransferTx(ctx, arg)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusCreated, result)</span>
}

func (server *Server) validAccount(ctx *gin.Context, accountID int64, currency string) bool <span class="cov8" title="1">{
        account, err := server.store.GetAccount(ctx, accountID)
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        ctx.JSON(http.StatusNotFound, errorResponse(err))
                        return false
                }</span>

                <span class="cov8" title="1">ctx.JSON(http.StatusInternalServerError, errorResponse(err))
                return false</span>
        }

        <span class="cov8" title="1">if account.Currency != currency </span><span class="cov8" title="1">{
                err := fmt.Errorf("account [%d] currency mismatch: %s vs %s", account.ID, account.Currency, currency)
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        db "github.com/ronymmoura/goliath-national-bank/db/sqlc"
        "github.com/ronymmoura/goliath-national-bank/util"
)

type CreateUserRequest struct {
        Password string `json:"password" binding:"required,min=6"`
        FullName string `json:"full_name" binding:"required"`
        Email    string `json:"email" binding:"required,email"`
}

type CreateUserResponse struct {
        ID                uuid.UUID `json:"id"`
        FullName          string    `json:"full_name"`
        Email             string    `json:"email"`
        PasswordChangedAt time.Time `json:"password_changed_at"`
        CreatedAt         time.Time `json:"created_at"`
}

func (server *Server) createUser(ctx *gin.Context) <span class="cov8" title="1">{
        var req CreateUserRequest

        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">hashedPassword, err := util.HashPassword(req.Password)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">arg := db.CreateUserParams{
                ID:             uuid.New(),
                HashedPassword: hashedPassword,
                FullName:       req.FullName,
                Email:          req.Email,
        }

        user, err := server.store.CreateUser(ctx, arg)
        if err != nil </span><span class="cov8" title="1">{

                if pgErr, ok := err.(*pgconn.PgError); ok </span><span class="cov8" title="1">{
                        switch pgErr.Code </span>{
                        case "23505":<span class="cov8" title="1">
                                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                                return</span>
                        }
                }

                <span class="cov8" title="1">ctx.JSON(http.StatusInternalServerError, errorResponse(err))
                return</span>
        }

        <span class="cov8" title="1">response := CreateUserResponse{
                ID:                user.ID,
                FullName:          user.FullName,
                Email:             user.Email,
                PasswordChangedAt: user.PasswordChangedAt,
                CreatedAt:         user.CreatedAt,
        }

        ctx.JSON(http.StatusCreated, response)</span>
}

type GetUserRequest struct {
        UserID string `uri:"user_id" binding:"required,uuid"`
}

type GetUserResponse struct {
        ID                uuid.UUID `json:"id"`
        FullName          string    `json:"full_name"`
        Email             string    `json:"email"`
        PasswordChangedAt time.Time `json:"password_changed_at"`
        CreatedAt         time.Time `json:"created_at"`
}

func (server *Server) getUser(ctx *gin.Context) <span class="cov8" title="1">{
        var req GetUserRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, errorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">userID := uuid.MustParse(req.UserID)

        user, err := server.store.GetUser(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        ctx.JSON(http.StatusNotFound, errorResponse(err))
                        return
                }</span>

                <span class="cov8" title="1">ctx.JSON(http.StatusInternalServerError, errorResponse(err))
                return</span>
        }

        <span class="cov8" title="1">response := GetUserResponse{
                ID:                user.ID,
                FullName:          user.FullName,
                Email:             user.Email,
                PasswordChangedAt: user.PasswordChangedAt,
                CreatedAt:         user.CreatedAt,
        }

        ctx.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "github.com/go-playground/validator/v10"
        "github.com/ronymmoura/goliath-national-bank/util"
)

var validCurrency validator.Func = func(fieldLevel validator.FieldLevel) bool <span class="cov8" title="1">{
        if currency, ok := fieldLevel.Field().Interface().(string); ok </span><span class="cov8" title="1">{
                return util.IsSupportedCurrency(currency)
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ronymmoura/goliath-national-bank/db/sqlc (interfaces: Store)

// Package mockdb is a generated GoMock package.
package mockdb

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
        db "github.com/ronymmoura/goliath-national-bank/db/sqlc"
)

// MockStore is a mock of Store interface.
type MockStore struct {
        ctrl     *gomock.Controller
        recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
        mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore <span class="cov8" title="1">{
        mock := &amp;MockStore{ctrl: ctrl}
        mock.recorder = &amp;MockStoreMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddAccountBalance mocks base method.
func (m *MockStore) AddAccountBalance(arg0 context.Context, arg1 db.AddAccountBalanceParams) (db.Account, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddAccountBalance", arg0, arg1)
        ret0, _ := ret[0].(db.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddAccountBalance indicates an expected call of AddAccountBalance.
func (mr *MockStoreMockRecorder) AddAccountBalance(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddAccountBalance", reflect.TypeOf((*MockStore)(nil).AddAccountBalance), arg0, arg1)
}</span>

// CreateAccount mocks base method.
func (m *MockStore) CreateAccount(arg0 context.Context, arg1 db.CreateAccountParams) (db.Account, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateAccount", arg0, arg1)
        ret0, _ := ret[0].(db.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateAccount indicates an expected call of CreateAccount.
func (mr *MockStoreMockRecorder) CreateAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccount", reflect.TypeOf((*MockStore)(nil).CreateAccount), arg0, arg1)
}</span>

// CreateEntry mocks base method.
func (m *MockStore) CreateEntry(arg0 context.Context, arg1 db.CreateEntryParams) (db.Entry, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateEntry", arg0, arg1)
        ret0, _ := ret[0].(db.Entry)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateEntry indicates an expected call of CreateEntry.
func (mr *MockStoreMockRecorder) CreateEntry(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEntry", reflect.TypeOf((*MockStore)(nil).CreateEntry), arg0, arg1)
}</span>

// CreateTransfer mocks base method.
func (m *MockStore) CreateTransfer(arg0 context.Context, arg1 db.CreateTransferParams) (db.Transfer, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTransfer", arg0, arg1)
        ret0, _ := ret[0].(db.Transfer)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateTransfer indicates an expected call of CreateTransfer.
func (mr *MockStoreMockRecorder) CreateTransfer(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTransfer", reflect.TypeOf((*MockStore)(nil).CreateTransfer), arg0, arg1)
}</span>

// CreateUser mocks base method.
func (m *MockStore) CreateUser(arg0 context.Context, arg1 db.CreateUserParams) (db.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockStoreMockRecorder) CreateUser(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockStore)(nil).CreateUser), arg0, arg1)
}</span>

// DeleteAccount mocks base method.
func (m *MockStore) DeleteAccount(arg0 context.Context, arg1 int64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteAccount", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteAccount indicates an expected call of DeleteAccount.
func (mr *MockStoreMockRecorder) DeleteAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccount", reflect.TypeOf((*MockStore)(nil).DeleteAccount), arg0, arg1)
}</span>

// DeleteUser mocks base method.
func (m *MockStore) DeleteUser(arg0 context.Context, arg1 uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockStoreMockRecorder) DeleteUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockStore)(nil).DeleteUser), arg0, arg1)
}</span>

// GetAccount mocks base method.
func (m *MockStore) GetAccount(arg0 context.Context, arg1 int64) (db.Account, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAccount", arg0, arg1)
        ret0, _ := ret[0].(db.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAccount indicates an expected call of GetAccount.
func (mr *MockStoreMockRecorder) GetAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockStore)(nil).GetAccount), arg0, arg1)
}</span>

// GetAccountForUpdate mocks base method.
func (m *MockStore) GetAccountForUpdate(arg0 context.Context, arg1 int64) (db.Account, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAccountForUpdate", arg0, arg1)
        ret0, _ := ret[0].(db.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAccountForUpdate indicates an expected call of GetAccountForUpdate.
func (mr *MockStoreMockRecorder) GetAccountForUpdate(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountForUpdate", reflect.TypeOf((*MockStore)(nil).GetAccountForUpdate), arg0, arg1)
}</span>

// GetEntry mocks base method.
func (m *MockStore) GetEntry(arg0 context.Context, arg1 int64) (db.Entry, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEntry", arg0, arg1)
        ret0, _ := ret[0].(db.Entry)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEntry indicates an expected call of GetEntry.
func (mr *MockStoreMockRecorder) GetEntry(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEntry", reflect.TypeOf((*MockStore)(nil).GetEntry), arg0, arg1)
}</span>

// GetTransfer mocks base method.
func (m *MockStore) GetTransfer(arg0 context.Context, arg1 int64) (db.Transfer, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTransfer", arg0, arg1)
        ret0, _ := ret[0].(db.Transfer)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTransfer indicates an expected call of GetTransfer.
func (mr *MockStoreMockRecorder) GetTransfer(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransfer", reflect.TypeOf((*MockStore)(nil).GetTransfer), arg0, arg1)
}</span>

// GetUser mocks base method.
func (m *MockStore) GetUser(arg0 context.Context, arg1 uuid.UUID) (db.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockStoreMockRecorder) GetUser(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockStore)(nil).GetUser), arg0, arg1)
}</span>

// GetUserByEmail mocks base method.
func (m *MockStore) GetUserByEmail(arg0 context.Context, arg1 string) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByEmail", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByEmail indicates an expected call of GetUserByEmail.
func (mr *MockStoreMockRecorder) GetUserByEmail(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByEmail", reflect.TypeOf((*MockStore)(nil).GetUserByEmail), arg0, arg1)
}</span>

// GetUserForUpdate mocks base method.
func (m *MockStore) GetUserForUpdate(arg0 context.Context, arg1 uuid.UUID) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserForUpdate", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserForUpdate indicates an expected call of GetUserForUpdate.
func (mr *MockStoreMockRecorder) GetUserForUpdate(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserForUpdate", reflect.TypeOf((*MockStore)(nil).GetUserForUpdate), arg0, arg1)
}</span>

// ListAccounts mocks base method.
func (m *MockStore) ListAccounts(arg0 context.Context, arg1 db.ListAccountsParams) ([]db.Account, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListAccounts", arg0, arg1)
        ret0, _ := ret[0].([]db.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListAccounts indicates an expected call of ListAccounts.
func (mr *MockStoreMockRecorder) ListAccounts(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccounts", reflect.TypeOf((*MockStore)(nil).ListAccounts), arg0, arg1)
}</span>

// ListEntries mocks base method.
func (m *MockStore) ListEntries(arg0 context.Context, arg1 db.ListEntriesParams) ([]db.Entry, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListEntries", arg0, arg1)
        ret0, _ := ret[0].([]db.Entry)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListEntries indicates an expected call of ListEntries.
func (mr *MockStoreMockRecorder) ListEntries(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEntries", reflect.TypeOf((*MockStore)(nil).ListEntries), arg0, arg1)
}</span>

// ListTransfers mocks base method.
func (m *MockStore) ListTransfers(arg0 context.Context, arg1 db.ListTransfersParams) ([]db.Transfer, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListTransfers", arg0, arg1)
        ret0, _ := ret[0].([]db.Transfer)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListTransfers indicates an expected call of ListTransfers.
func (mr *MockStoreMockRecorder) ListTransfers(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTransfers", reflect.TypeOf((*MockStore)(nil).ListTransfers), arg0, arg1)
}</span>

// TransferTx mocks base method.
func (m *MockStore) TransferTx(arg0 context.Context, arg1 db.TransferTxParams) (db.TransferTxResult, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TransferTx", arg0, arg1)
        ret0, _ := ret[0].(db.TransferTxResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// TransferTx indicates an expected call of TransferTx.
func (mr *MockStoreMockRecorder) TransferTx(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransferTx", reflect.TypeOf((*MockStore)(nil).TransferTx), arg0, arg1)
}</span>

// UpdateAccount mocks base method.
func (m *MockStore) UpdateAccount(arg0 context.Context, arg1 db.UpdateAccountParams) (db.Account, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateAccount", arg0, arg1)
        ret0, _ := ret[0].(db.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateAccount indicates an expected call of UpdateAccount.
func (mr *MockStoreMockRecorder) UpdateAccount(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccount", reflect.TypeOf((*MockStore)(nil).UpdateAccount), arg0, arg1)
}</span>

// UpdateUser mocks base method.
func (m *MockStore) UpdateUser(arg0 context.Context, arg1 db.UpdateUserParams) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockStoreMockRecorder) UpdateUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockStore)(nil).UpdateUser), arg0, arg1)
}</span>

// UpdateUserPassword mocks base method.
func (m *MockStore) UpdateUserPassword(arg0 context.Context, arg1 db.UpdateUserPasswordParams) (db.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUserPassword", arg0, arg1)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUserPassword indicates an expected call of UpdateUserPassword.
func (mr *MockStoreMockRecorder) UpdateUserPassword(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUserPassword", reflect.TypeOf((*MockStore)(nil).UpdateUserPassword), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: account.sql

package db

import (
        "context"

        "github.com/google/uuid"
)

const addAccountBalance = `-- name: AddAccountBalance :one
UPDATE accounts
SET balance = balance + $1
WHERE id = $2
RETURNING id, balance, currency, created_at, user_id
`

type AddAccountBalanceParams struct {
        Amount int64 `json:"amount"`
        ID     int64 `json:"id"`
}

func (q *Queries) AddAccountBalance(ctx context.Context, arg AddAccountBalanceParams) (Account, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, addAccountBalance, arg.Amount, arg.ID)
        var i Account
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Balance,
                &amp;i.Currency,
                &amp;i.CreatedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>

const createAccount = `-- name: CreateAccount :one

INSERT INTO accounts (
  user_id,
  balance,
  currency
)
VALUES (
  $1,
  $2,
  $3
)
RETURNING id, balance, currency, created_at, user_id
`

type CreateAccountParams struct {
        UserID   uuid.UUID `json:"user_id"`
        Balance  int64     `json:"balance"`
        Currency string    `json:"currency"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createAccount, arg.UserID, arg.Balance, arg.Currency)
        var i Account
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Balance,
                &amp;i.Currency,
                &amp;i.CreatedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteAccount, id)
        return err
}</span>

const getAccount = `-- name: GetAccount :one
SELECT id, balance, currency, created_at, user_id
FROM accounts
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, id int64) (Account, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getAccount, id)
        var i Account
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Balance,
                &amp;i.Currency,
                &amp;i.CreatedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>

const getAccountForUpdate = `-- name: GetAccountForUpdate :one
SELECT id, balance, currency, created_at, user_id
FROM accounts
WHERE id = $1
LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetAccountForUpdate(ctx context.Context, id int64) (Account, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getAccountForUpdate, id)
        var i Account
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Balance,
                &amp;i.Currency,
                &amp;i.CreatedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>

const listAccounts = `-- name: ListAccounts :many
SELECT id, balance, currency, created_at, user_id
FROM accounts
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListAccountsParams struct {
        Limit  int32 `json:"limit"`
        Offset int32 `json:"offset"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, listAccounts, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Account{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Account
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Balance,
                        &amp;i.Currency,
                        &amp;i.CreatedAt,
                        &amp;i.UserID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET balance = $2
WHERE id = $1
RETURNING id, balance, currency, created_at, user_id
`

type UpdateAccountParams struct {
        ID      int64 `json:"id"`
        Balance int64 `json:"balance"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, updateAccount, arg.ID, arg.Balance)
        var i Account
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Balance,
                &amp;i.Currency,
                &amp;i.CreatedAt,
                &amp;i.UserID,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package db

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: entry.sql

package db

import (
        "context"
)

const createEntry = `-- name: CreateEntry :one

INSERT INTO entries
(
  account_id,
  amount
)
VALUES (
  $1,
  $2
)
RETURNING id, account_id, amount, created_at
`

type CreateEntryParams struct {
        AccountID int64 `json:"account_id"`
        Amount    int64 `json:"amount"`
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (Entry, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createEntry, arg.AccountID, arg.Amount)
        var i Entry
        err := row.Scan(
                &amp;i.ID,
                &amp;i.AccountID,
                &amp;i.Amount,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getEntry = `-- name: GetEntry :one
SELECT id, account_id, amount, created_at
FROM entries
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEntry(ctx context.Context, id int64) (Entry, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getEntry, id)
        var i Entry
        err := row.Scan(
                &amp;i.ID,
                &amp;i.AccountID,
                &amp;i.Amount,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listEntries = `-- name: ListEntries :many
SELECT id, account_id, amount, created_at
FROM entries
WHERE account_id = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type ListEntriesParams struct {
        AccountID int64 `json:"account_id"`
        Limit     int32 `json:"limit"`
        Offset    int32 `json:"offset"`
}

func (q *Queries) ListEntries(ctx context.Context, arg ListEntriesParams) ([]Entry, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, listEntries, arg.AccountID, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Entry{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Entry
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.AccountID,
                        &amp;i.Amount,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package db

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
)

// Store defines all functions to execute db queries and transactions
type Store interface {
        Querier

        TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error)
}

// SQLStore provides all functions to execute SQL queries and transactions
type SQLStore struct {
        connPool *pgxpool.Pool
        *Queries
}

// NewStore creates a new store
func NewStore(connPool *pgxpool.Pool) Store <span class="cov8" title="1">{
        return &amp;SQLStore{
                connPool: connPool,
                Queries:  New(connPool),
        }
}</span>

// execTx executes a function within a database transaction
func (store *SQLStore) execTx(ctx context.Context, fn func(*Queries) error) error <span class="cov8" title="1">{
        tx, err := store.connPool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">q := New(tx)

        err = fn(q)
        if err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tx err: %v, rb err: %v", err, err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return tx.Commit(ctx)</span>
}

type TransferTxParams struct {
        FromAccountID int64 `json:"from_account_id"`
        ToAccountID   int64 `json:"to_account_id"`
        Amount        int64 `json:"amount"`
}

type TransferTxResult struct {
        Transfer    Transfer `json:"transfer"`
        FromAccount Account  `json:"from_account"`
        ToAccount   Account  `json:"to_account"`
        FromEntry   Entry    `json:"from_entry"`
        ToEntry     Entry    `json:"to_entry"`
}

func (store *SQLStore) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) <span class="cov8" title="1">{
        var result TransferTxResult

        err := store.execTx(ctx, func(q *Queries) error </span><span class="cov8" title="1">{
                var err error

                result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams{
                        FromAccountID: arg.FromAccountID,
                        ToAccountID:   arg.ToAccountID,
                        Amount:        arg.Amount,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams{
                        AccountID: arg.FromAccountID,
                        Amount:    -arg.Amount,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams{
                        AccountID: arg.ToAccountID,
                        Amount:    arg.Amount,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // update account's balance
                <span class="cov8" title="1">if arg.FromAccountID &lt; arg.ToAccountID </span><span class="cov8" title="1">{
                        result.FromAccount, result.ToAccount, err = addMoney(ctx, q, arg.FromAccountID, -arg.Amount, arg.ToAccountID, arg.Amount)
                }</span> else<span class="cov8" title="1"> {
                        result.ToAccount, result.FromAccount, err = addMoney(ctx, q, arg.ToAccountID, arg.Amount, arg.FromAccountID, -arg.Amount)
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return result, err</span>
}

func addMoney(
        ctx context.Context,
        q *Queries,
        accountID1 int64,
        amount1 int64,
        accountID2 int64,
        amount2 int64,
) (account1 Account, account2 Account, err error) <span class="cov8" title="1">{
        account1, err = q.AddAccountBalance(ctx, AddAccountBalanceParams{
                ID:     accountID1,
                Amount: amount1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">account2, err = q.AddAccountBalance(ctx, AddAccountBalanceParams{
                ID:     accountID2,
                Amount: amount2,
        })

        return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: transfer.sql

package db

import (
        "context"
)

const createTransfer = `-- name: CreateTransfer :one
INSERT INTO transfers (
  from_account_id,
  to_account_id,
  amount
) VALUES (
  $1, $2, $3
) RETURNING id, from_account_id, to_account_id, amount, created_at
`

type CreateTransferParams struct {
        FromAccountID int64 `json:"from_account_id"`
        ToAccountID   int64 `json:"to_account_id"`
        Amount        int64 `json:"amount"`
}

func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) (Transfer, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createTransfer, arg.FromAccountID, arg.ToAccountID, arg.Amount)
        var i Transfer
        err := row.Scan(
                &amp;i.ID,
                &amp;i.FromAccountID,
                &amp;i.ToAccountID,
                &amp;i.Amount,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getTransfer = `-- name: GetTransfer :one
SELECT id, from_account_id, to_account_id, amount, created_at FROM transfers
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTransfer(ctx context.Context, id int64) (Transfer, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getTransfer, id)
        var i Transfer
        err := row.Scan(
                &amp;i.ID,
                &amp;i.FromAccountID,
                &amp;i.ToAccountID,
                &amp;i.Amount,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listTransfers = `-- name: ListTransfers :many
SELECT id, from_account_id, to_account_id, amount, created_at FROM transfers
WHERE 
    from_account_id = $1 OR
    to_account_id = $2
ORDER BY id
LIMIT $3
OFFSET $4
`

type ListTransfersParams struct {
        FromAccountID int64 `json:"from_account_id"`
        ToAccountID   int64 `json:"to_account_id"`
        Limit         int32 `json:"limit"`
        Offset        int32 `json:"offset"`
}

func (q *Queries) ListTransfers(ctx context.Context, arg ListTransfersParams) ([]Transfer, error) <span class="cov8" title="1">{
        rows, err := q.db.Query(ctx, listTransfers,
                arg.FromAccountID,
                arg.ToAccountID,
                arg.Limit,
                arg.Offset,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Transfer{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Transfer
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.FromAccountID,
                        &amp;i.ToAccountID,
                        &amp;i.Amount,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: user.sql

package db

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO users (
  id,
  hashed_password,
  full_name,
  email
)
VALUES (
  $1,
  $2,
  $3,
  $4
)
RETURNING id, hashed_password, full_name, email, password_changed_at, created_at
`

type CreateUserParams struct {
        ID             uuid.UUID `json:"id"`
        HashedPassword string    `json:"hashed_password"`
        FullName       string    `json:"full_name"`
        Email          string    `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, createUser,
                arg.ID,
                arg.HashedPassword,
                arg.FullName,
                arg.Email,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.HashedPassword,
                &amp;i.FullName,
                &amp;i.Email,
                &amp;i.PasswordChangedAt,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        _, err := q.db.Exec(ctx, deleteUser, id)
        return err
}</span>

const getUser = `-- name: GetUser :one
SELECT id, hashed_password, full_name, email, password_changed_at, created_at
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getUser, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.HashedPassword,
                &amp;i.FullName,
                &amp;i.Email,
                &amp;i.PasswordChangedAt,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, hashed_password, full_name, email, password_changed_at, created_at
FROM users
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.HashedPassword,
                &amp;i.FullName,
                &amp;i.Email,
                &amp;i.PasswordChangedAt,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getUserForUpdate = `-- name: GetUserForUpdate :one
SELECT id, hashed_password, full_name, email, password_changed_at, created_at
FROM users
WHERE id = $1
LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetUserForUpdate(ctx context.Context, id uuid.UUID) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, getUserForUpdate, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.HashedPassword,
                &amp;i.FullName,
                &amp;i.Email,
                &amp;i.PasswordChangedAt,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
  full_name = $2,
  email = $3
WHERE id = $1
RETURNING id, hashed_password, full_name, email, password_changed_at, created_at
`

type UpdateUserParams struct {
        ID       uuid.UUID `json:"id"`
        FullName string    `json:"full_name"`
        Email    string    `json:"email"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, updateUser, arg.ID, arg.FullName, arg.Email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.HashedPassword,
                &amp;i.FullName,
                &amp;i.Email,
                &amp;i.PasswordChangedAt,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET 
  hashed_password = $2,
  password_changed_at = $3
WHERE id = $1
RETURNING id, hashed_password, full_name, email, password_changed_at, created_at
`

type UpdateUserPasswordParams struct {
        ID                uuid.UUID `json:"id"`
        HashedPassword    string    `json:"hashed_password"`
        PasswordChangedAt time.Time `json:"password_changed_at"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, updateUserPassword, arg.ID, arg.HashedPassword, arg.PasswordChangedAt)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.HashedPassword,
                &amp;i.FullName,
                &amp;i.Email,
                &amp;i.PasswordChangedAt,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "context"
        "log"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/ronymmoura/goliath-national-bank/api"
        db "github.com/ronymmoura/goliath-national-bank/db/sqlc"
        "github.com/ronymmoura/goliath-national-bank/util"
)

func main() <span class="cov0" title="0">{

        config, err := util.LoadConfig(".")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot load config:", err)
        }</span>

        <span class="cov0" title="0">connPool, err := pgxpool.New(context.Background(), config.DBSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot connect to db:", err)
        }</span>

        <span class="cov0" title="0">store := db.NewStore(connPool)
        server, err := api.NewServer(config, store)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot start server:", err)
        }</span>

        <span class="cov0" title="0">err = server.Start(config.ServerAddress)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot start server:", err)
        }</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">package token

import (
        "errors"
        "fmt"
        "time"

        "github.com/dgrijalva/jwt-go"
)

const minSecretKeySize = 32

var (
        ErrInvalidJWTKeySize = fmt.Errorf("invalid key size: must be at least %d characters", minSecretKeySize)
)

type JWTMaker struct {
        secretKey string
}

func NewJWTMaker(secretKey string) (Maker, error) <span class="cov8" title="1">{
        if len(secretKey) &lt; minSecretKeySize </span><span class="cov8" title="1">{
                return nil, ErrInvalidJWTKeySize
        }</span>

        <span class="cov8" title="1">return &amp;JWTMaker{secretKey}, nil</span>
}

func (maker *JWTMaker) CreateToken(username string, duration time.Duration) (string, error) <span class="cov8" title="1">{
        payload, err := NewPayload(username, duration)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)
        return jwtToken.SignedString([]byte(maker.secretKey))</span>
}

func (maker *JWTMaker) VerifyToken(token string) (*Payload, error) <span class="cov8" title="1">{
        keyFunc := func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                _, ok := token.Method.(*jwt.SigningMethodHMAC)
                if !ok </span><span class="cov8" title="1">{
                        return nil, ErrInvalidToken
                }</span>

                <span class="cov8" title="1">return []byte(maker.secretKey), nil</span>
        }

        <span class="cov8" title="1">jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload{}, keyFunc)
        if err != nil </span><span class="cov8" title="1">{
                verr, ok := err.(*jwt.ValidationError)
                if ok &amp;&amp; errors.Is(verr.Inner, ErrExpiredToken) </span><span class="cov8" title="1">{
                        return nil, ErrExpiredToken
                }</span>

                <span class="cov8" title="1">return nil, ErrInvalidToken</span>
        }

        <span class="cov8" title="1">return GetPayload(jwtToken)</span>
}

func GetPayload(jwtToken *jwt.Token) (*Payload, error) <span class="cov8" title="1">{
        payload, ok := jwtToken.Claims.(*Payload)
        if !ok </span><span class="cov8" title="1">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">return payload, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package token

import (
        "fmt"
        "time"

        "golang.org/x/crypto/chacha20poly1305"

        "github.com/o1egl/paseto"
)

var (
        ErrInvalidKeySize = fmt.Errorf("invalid key size: must be exactly %d characters", chacha20poly1305.KeySize)
)

type PasetoMaker struct {
        paseto       *paseto.V2
        symmetricKey []byte
}

func NewPasetoMaker(symmetricKey string) (Maker, error) <span class="cov8" title="1">{
        if len(symmetricKey) != chacha20poly1305.KeySize </span><span class="cov8" title="1">{
                return nil, ErrInvalidKeySize
        }</span>

        <span class="cov8" title="1">maker := &amp;PasetoMaker{
                paseto:       paseto.NewV2(),
                symmetricKey: []byte(symmetricKey),
        }

        return maker, nil</span>
}

func (maker *PasetoMaker) CreateToken(username string, duration time.Duration) (string, error) <span class="cov8" title="1">{
        payload, err := NewPayload(username, duration)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return maker.paseto.Encrypt(maker.symmetricKey, payload, nil)</span>
}

func (maker *PasetoMaker) VerifyToken(token string) (*Payload, error) <span class="cov8" title="1">{
        payload := &amp;Payload{}

        err := maker.paseto.Decrypt(token, maker.symmetricKey, payload, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">err = payload.Valid()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return payload, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package token

import (
        "errors"
        "time"

        "github.com/google/uuid"
)

var (
        ErrExpiredToken = errors.New("token has expired")
        ErrInvalidToken = errors.New("token is invalid")
        ErrEmptyUser    = errors.New("username is empty")
)

type Payload struct {
        ID        uuid.UUID `json:"id"`
        Username  string    `json:"username"`
        IssuedAt  time.Time `json:"issued_at"`
        ExpiredAt time.Time `json:"expired_at"`
}

func NewPayload(username string, duration time.Duration) (*Payload, error) <span class="cov8" title="1">{
        if username == "" </span><span class="cov8" title="1">{
                return nil, ErrEmptyUser
        }</span>

        <span class="cov8" title="1">tokenID := uuid.New()

        payload := &amp;Payload{
                ID:        tokenID,
                Username:  username,
                IssuedAt:  time.Now(),
                ExpiredAt: time.Now().Add(duration),
        }

        return payload, nil</span>
}

func (payload *Payload) Valid() error <span class="cov8" title="1">{
        if time.Now().After(payload.ExpiredAt) </span><span class="cov8" title="1">{
                return ErrExpiredToken
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package util

const (
        USD = "USD"
        EUR = "EUR"
        CAD = "CAD"
        BRL = "BRL"
)

var currencies []string = []string{USD, EUR, CAD, BRL}

func IsSupportedCurrency(currency string) bool <span class="cov8" title="1">{
        for _, i := range currencies </span><span class="cov8" title="1">{
                if i == currency </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package util

import (
        "fmt"

        "golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        fmt.Printf("%s\n", password)
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to hash password: %w", err)
        }</span>
        <span class="cov8" title="1">return string(hashedPassword), nil</span>
}

func CheckPassword(password string, hashedPassword string) error <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package util

import (
        "fmt"
        "math/rand"
        "strings"
        "time"
)

const alphabet = "abcdefghijklmnopqrstuvwxyz"

func init() <span class="cov8" title="1">{
        rand.NewSource(time.Now().UnixNano())
}</span>

func RandomInt(min, max int64) int64 <span class="cov8" title="1">{
        return min + rand.Int63n(max-min+1)
}</span>

func RandomString(size int) string <span class="cov8" title="1">{
        var sb strings.Builder
        k := len(alphabet)

        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                c := alphabet[rand.Intn(k)]
                sb.WriteByte(c)
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

func RandomOwner() string <span class="cov8" title="1">{
        return RandomString(6)
}</span>

func RandomMoney() int64 <span class="cov8" title="1">{
        return RandomInt(1, 1000)
}</span>

func RandomCurrency() string <span class="cov8" title="1">{
        currenciesCount := len(currencies)

        return currencies[rand.Intn(currenciesCount)]
}</span>

func RandomEmail() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s@%s.%s", RandomString(10), RandomString(5), "com")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package util

import (
        "time"

        "github.com/spf13/viper"
)

type Config struct {
        Environment         string        `mapstructure:"ENVIRONMENT"`
        DBSource            string        `mapstructure:"DB_SOURCE"`
        MigrationURL        string        `mapstructure:"MIGRATION_URL"`
        ServerAddress       string        `mapstructure:"SERVER_ADDRESS"`
        TokenSymmetricKey   string        `mapstructure:"TOKEN_SYMMETRIC_KEY"`
        AccessTokenDuration time.Duration `mapstructure:"ACCESS_TOKEN_DURATION"`
}

func LoadConfig(path string) (config Config, err error) <span class="cov8" title="1">{
        viper.AddConfigPath(path)
        viper.SetConfigName("app")
        viper.SetConfigType("env")

        viper.AutomaticEnv()

        err = viper.ReadInConfig()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">err = viper.Unmarshal(&amp;config)

        return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
